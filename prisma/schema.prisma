generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// ---------- Internal users: cashiers / admins / agents ----------
model User {
  id           Int      @id @default(autoincrement())
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  name         String
  username     String   @unique
  passwordHash String
  role         UserRole @default(CASHIER)
  isActive     Boolean  @default(true)

  // relations
  pointTransactions PointTransaction[] @relation("TransactionPerformedBy")
  dailyChargeChecks DailyChargeCheck[] @relation("DailyChecksPerformedBy")
  contactsCreated   ClientContact[]    @relation("ContactsCreatedBy")
  chatMessages      ChatMessage[]      @relation("OperatorMessages")
}

enum UserRole {
  ADMIN
  CASHIER
  AGENT
}

// ---------- Players / clients of the platform ----------
model Client {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // minimal identification
  username String  @unique
  phone    String? @unique

  status ClientStatus @default(ACTIVE)

  // points = pesos
  pointsBalance Int @default(0)

  // how they came to us (ads, organic, etc.)
  marketingSource   MarketingSource? @relation(fields: [marketingSourceId], references: [id])
  marketingSourceId Int?

  // relations
  pointTransactions PointTransaction[]
  contacts          ClientContact[]
  dailyChargeChecks DailyChargeCheck[]
  chatMessages      ChatMessage[]
}

enum ClientStatus {
  ACTIVE
  INACTIVE
  BANNED
}

// ---------- Where did this client come from? (ads etc.) ----------
model MarketingSource {
  id        Int      @id @default(autoincrement())
  name      String // e.g. "Instagram Ads", "TikTok Ads"
  platform  String? // "instagram", "facebook", "tiktok", etc.
  campaign  String? // campaign name or id from Ads Manager
  createdAt DateTime @default(now())

  clients Client[]
}

// ---------- All movements of points (money) ----------
model PointTransaction {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())

  client   Client @relation(fields: [clientId], references: [id])
  clientId Int

  amount Int // + for charge, - for redeem
  type   TransactionType
  method PaymentMethod?

  description   String?
  referenceCode String? // ticket number, transaction id, etc.

  cashier   User? @relation("TransactionPerformedBy", fields: [cashierId], references: [id])
  cashierId Int?

  @@index([clientId, createdAt])
  @@index([cashierId, createdAt])
}

enum TransactionType {
  CHARGE // user loaded points
  REDEEM // user spent points
  ADJUSTMENT // manual corrections
}

enum PaymentMethod {
  CASH
  CARD
  TRANSFER
  OTHER
}

// ---------- Contacts / conversations with the client ----------
model ClientContact {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())

  client   Client @relation(fields: [clientId], references: [id])
  clientId Int

  channel   ContactChannel
  direction ContactDirection

  viaAd    Boolean @default(false) // came from ad?
  campaign String? // optional ads campaign id/name
  message  String? // notes of what was talked

  handledBy   User? @relation("ContactsCreatedBy", fields: [handledById], references: [id])
  handledById Int?

  @@index([clientId, createdAt])
  @@index([channel, createdAt])
}

enum ContactChannel {
  WHATSAPP
  INSTAGRAM
  FACEBOOK
  TIKTOK
  CALL
  EMAIL
  SMS
  IN_PERSON
  OTHER
}

enum ContactDirection {
  INBOUND // client -> us
  OUTBOUND // us -> client
}

// ---------- Daily checkbox: did this client charge today? ----------
model DailyChargeCheck {
  id Int @id @default(autoincrement())

  // Store as midnight of that day, and in the app you treat it as "date"
  date DateTime

  client   Client @relation(fields: [clientId], references: [id])
  clientId Int

  hasCharged Boolean // cashier's checkbox: yes/no
  checkedAt  DateTime @default(now())

  checkedBy   User? @relation("DailyChecksPerformedBy", fields: [checkedById], references: [id])
  checkedById Int?

  @@unique([clientId, date]) // only one check per client per day
  @@index([date])
}

// ---------- Chat messages between operators and clients ----------
model ChatMessage {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())

  // Client involved in this conversation (OPTIONAL - can be null for guest users)
  client         Client? @relation(fields: [clientId], references: [id])
  clientId       Int?

  // Guest/unregistered user identifiers
  clientSocketId String? // Socket ID for real-time correlation
  guestUsername  String? // Username for guests not yet in database
  guestPhone     String? // Phone for guests not yet in database

  // Who sent this message
  senderType MessageSenderType // CLIENT or OPERATOR

  // If sent by operator
  operator   User? @relation("OperatorMessages", fields: [operatorId], references: [id])
  operatorId Int?

  // Message content
  messageType MessageType // TEXT or IMAGE
  text        String? // for text messages
  imageUrl    String? // for image messages (base64 or URL)
  imageName   String? // original filename
  mimeType    String? // image MIME type

  // Message metadata
  isRead     Boolean  @default(false)
  readAt     DateTime?
  sessionId  String? // Group messages by conversation session

  @@index([clientId, createdAt])
  @@index([sessionId, createdAt])
  @@index([operatorId, createdAt])
  @@index([guestUsername, createdAt])
  @@index([clientSocketId, createdAt])
}

enum MessageSenderType {
  CLIENT
  OPERATOR
}

enum MessageType {
  TEXT
  IMAGE
}
